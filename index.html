<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LRID™ Assessment</title>
  <style>
    :root{
      --bg:#f6f7fb; --card:#fff; --border:#e6e7ee; --text:#111; --muted:#555;
      --btn:#111; --btnText:#fff; --danger:#b00020; --ok:#0a6;
      --shadow:0 6px 18px rgba(0,0,0,.06);
      --r:14px;
    }
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text);}
    .wrap{max-width:980px;margin:0 auto;padding:26px 18px 70px;}
    .top{display:flex;justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap;}
    h1{margin:0;font-size:22px;}
    .sub{margin:6px 0 0;color:var(--muted);font-size:14px;line-height:1.4;}
    .pill{display:inline-block;font-size:12px;border:1px solid var(--border);border-radius:999px;padding:4px 10px;background:#fff;color:#333}
    .card{margin-top:16px;background:var(--card);border:1px solid var(--border);border-radius:var(--r);padding:18px 18px 16px;box-shadow:var(--shadow);}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;}
    @media (max-width:820px){.grid{grid-template-columns:1fr;}}
    label{display:block;font-size:13px;color:#222;margin:2px 0 6px;}
    input,textarea,select{
      width:100%;box-sizing:border-box;border:1px solid var(--border);border-radius:12px;
      padding:10px 12px;font-size:14px;background:#fff;color:#111;
    }
    textarea{min-height:84px;resize:vertical;}
    .hr{height:1px;background:var(--border);margin:16px 0;}
    .hint{font-size:12px;color:var(--muted);line-height:1.45;margin-top:6px;}
    .error{color:var(--danger);}
    .ok{color:var(--ok);}
    .btnRow{display:flex;gap:10px;flex-wrap:wrap;margin-top:14px;align-items:center;}
    button{
      border:0;border-radius:12px;background:var(--btn);color:var(--btnText);
      padding:11px 14px;font-size:14px;cursor:pointer;
    }
    button:disabled{opacity:.6;cursor:not-allowed;}
    .ghost{background:#fff;color:#111;border:1px solid var(--border);}
    .status{font-size:13px;color:var(--muted);}
    .progressWrap{display:flex;align-items:center;gap:10px;flex-wrap:wrap;margin-top:10px;}
    .bar{height:10px;background:#fff;border:1px solid var(--border);border-radius:999px;overflow:hidden;min-width:220px;}
    .bar > div{height:10px;background:#111;width:0%;}
    .sectionTitle{font-size:16px;font-weight:700;margin:0 0 6px;}
    .qCard{border:1px solid var(--border);border-radius:14px;padding:14px;background:#fff;}
    .qMeta{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;margin-bottom:8px;}
    .qid{font-size:12px;color:#333;border:1px solid var(--border);border-radius:999px;padding:2px 8px;background:#fff;}
    .req{font-size:12px;color:#333;}
    .qText{font-size:14px;line-height:1.45;margin:6px 0 10px;}
    .opts{display:flex;gap:10px;flex-wrap:wrap;}
    .opt{
      border:1px solid var(--border);border-radius:12px;padding:8px 10px;background:#fff;
      display:flex;align-items:center;gap:8px;cursor:pointer;user-select:none;
    }
    .opt input{width:auto;}
    .likert{display:grid;grid-template-columns:repeat(5, minmax(0,1fr));gap:8px;}
    @media (max-width:640px){.likert{grid-template-columns:repeat(5, minmax(0,1fr));}}
    .likert .opt{justify-content:center;padding:10px 0;}
    .tiny{font-size:12px;color:var(--muted);}
    .missingBox{margin-top:10px;padding:10px 12px;border:1px dashed var(--border);border-radius:12px;background:#fff;}
    .missingList{margin:6px 0 0;padding-left:18px;color:#333;font-size:13px;}
    .footerSticky{
      position:sticky;bottom:12px;z-index:5;margin-top:18px;
    }
    .footerSticky .card{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>LRID™ Assessment</h1>
        <p class="sub">
          Complete the questionnaire and click <b>Send response</b>. A PDF report will be generated and emailed to the designated address.
        </p>
      </div>
      <div class="pill" id="healthPill">API: checking…</div>
    </div>

    <!-- Respondent -->
    <div class="card">
      <div class="grid">
        <div>
          <label for="name">Respondent name</label>
          <input id="name" placeholder="Full name" autocomplete="name" />
        </div>
        <div>
          <label for="email">Respondent email (report recipient)</label>
          <input id="email" placeholder="name@company.com" autocomplete="email" />
          <div class="hint">This email will be used to send the PDF report.</div>
        </div>
        <div>
          <label for="org">Organization</label>
          <input id="org" placeholder="Company / Institution" />
        </div>
        <div>
          <label for="caseId">Case ID (optional)</label>
          <input id="caseId" placeholder="Leave empty to auto-generate" />
          <div class="hint">If provided, it must be unique.</div>
        </div>
      </div>

      <div class="progressWrap">
        <div class="bar" aria-label="progress"><div id="progressFill"></div></div>
        <div class="status" id="progressText">Loading questions…</div>
        <button class="ghost" type="button" onclick="resetLocalDraft()">Reset saved draft</button>
      </div>

      <div id="missingBox" class="missingBox" style="display:none;">
        <div class="tiny"><b>Missing required answers:</b></div>
        <ul id="missingList" class="missingList"></ul>
      </div>
    </div>

    <!-- Questions -->
    <div class="card" id="questionsCard">
      <div id="questionsStatus" class="status">Loading configuration from <span class="mono">/config/questions.lrid.v1.json</span>…</div>
      <div id="questionsRoot" style="margin-top:12px;"></div>

      <!-- Hard fallback if config missing -->
      <div id="fallback" style="display:none; margin-top:16px;">
        <div class="hr"></div>
        <div class="status error">
          Could not load the questions configuration. Fallback mode is enabled (manual JSON answers).
        </div>
        <label for="answersJson" style="margin-top:10px;">Answers (JSON fallback)</label>
        <textarea id="answersJson" placeholder='Paste answers JSON array here, e.g. [{"question_id":"DI01","value":5}]'></textarea>
        <div class="hint">
          This is a safety fallback. In production, fix the config path or JSON format.
        </div>
      </div>
    </div>

    <!-- Submit -->
    <div class="footerSticky">
      <div class="card">
        <div>
          <div class="status" id="submitStatus"></div>
          <div class="hint" id="submitHint"></div>
        </div>
        <div class="btnRow" style="margin:0;">
          <button id="sendBtn" type="button" onclick="submitForm()">Send response</button>
          <button class="ghost" type="button" onclick="scrollToTop()">Back to top</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // Globals
    // =========================
    const CONFIG_URL = "/config/questions.lrid.v1.json";
    const STORAGE_KEY = "lrid_draft_v1";
    let CONFIG = null;
    let QUESTIONS = [];   // normalized flat list
    let SECTIONS = [];    // {title, questions:[]}
    let ANSWERS = {};     // question_id -> value
    let REQUIRED_IDS = []; // required question_id list
    let FALLBACK_MODE = false;

    // =========================
    // Utilities
    // =========================
    function $(id){ return document.getElementById(id); }

    function setPill(text){ $("healthPill").textContent = text; }

    async function checkHealth() {
      try {
        const r = await fetch("/api/health", { cache:"no-store" });
        const j = await r.json();
        setPill(j && j.status === "ok" ? "API: OK" : "API: issue");
      } catch { setPill("API: offline"); }
    }

    function esc(s){ return String(s ?? "").replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c])); }

    function normalizeConfig(raw){
      // Accept common shapes:
      // 1) { questions: [...] }
      // 2) { sections: [{title, questions:[...]}] }
      // 3) [...] (array of questions)
      // 4) { data: { questions:[...] } }
      if (Array.isArray(raw)) return { sections: [{ title: "Assessment", questions: raw }] };
      if (raw && Array.isArray(raw.questions)) return { sections: [{ title: raw.title || "Assessment", questions: raw.questions }] };
      if (raw && raw.data && Array.isArray(raw.data.questions)) return { sections: [{ title: raw.title || "Assessment", questions: raw.data.questions }] };
      if (raw && Array.isArray(raw.sections)) return { sections: raw.sections };
      // Unknown shape -> fallback
      return null;
    }

    function normalizeQuestion(q, idx){
      // Try to map various fields into a consistent schema
      const qid = q.question_id || q.questionId || q.id || q.qid || q.code || `Q${idx+1}`;
      const text = q.text || q.label || q.question || q.prompt || q.title || `Question ${idx+1}`;
      const required = (q.required !== undefined) ? !!q.required : true; // default required
      const typeRaw = (q.type || q.kind || q.input_type || q.answer_type || "").toLowerCase();

      // Options might be: q.options, q.choices, q.answers
      const optionsRaw = q.options || q.choices || q.answers || null;
      let options = null;

      if (Array.isArray(optionsRaw)) {
        options = optionsRaw.map((o, i) => {
          if (typeof o === "string" || typeof o === "number") return { label: String(o), value: o };
          return {
            label: String(o.label ?? o.text ?? o.name ?? o.title ?? `Option ${i+1}`),
            value: (o.value ?? o.id ?? o.code ?? o.key ?? o.label ?? o.text ?? i+1)
          };
        });
      }

      // Determine type
      let type = "likert";
      if (typeRaw.includes("likert")) type = "likert";
      else if (typeRaw.includes("radio") || typeRaw.includes("single")) type = "single";
      else if (typeRaw.includes("multi") || typeRaw.includes("checkbox")) type = "multi";
      else if (typeRaw.includes("text") || typeRaw.includes("open")) type = (q.long === true || typeRaw.includes("long")) ? "longtext" : "text";
      else if (typeRaw.includes("select")) type = "single";

      // If options exist and type unknown -> single
      if (!typeRaw && options && options.length) type = "single";

      // Likert scale
      const scale = q.scale || q.likert || null; // could be {min,max,labels}
      const likert = {
        min: 1,
        max: 5,
        labels: q.labels || (scale && scale.labels) || null
      };
      if (scale && typeof scale === "object") {
        if (Number.isFinite(scale.min)) likert.min = scale.min;
        if (Number.isFinite(scale.max)) likert.max = scale.max;
      }

      // If the config explicitly provides numeric range
      if (Number.isFinite(q.min)) likert.min = q.min;
      if (Number.isFinite(q.max)) likert.max = q.max;

      // If "options" provided but looks like 1..5, treat as likert
      if (options && options.length >= 3) {
        const allNums = options.every(o => Number.isFinite(Number(o.value)));
        if (type === "single" && allNums) {
          const nums = options.map(o => Number(o.value)).sort((a,b)=>a-b);
          if (nums[0] === 1 && nums[nums.length-1] === 5) type = "likert";
        }
      }

      return { question_id: String(qid), text: String(text), required, type, options, likert };
    }

    function buildModel(cfg){
      const sections = (cfg.sections || []).map((s, si) => {
        const title = s.title || s.name || s.section || `Section ${si+1}`;
        const qs = Array.isArray(s.questions) ? s.questions : (Array.isArray(s.items) ? s.items : []);
        const normQs = qs.map((q, qi) => normalizeQuestion(q, qi));
        return { title: String(title), questions: normQs };
      });

      // Flatten
      const flat = sections.flatMap(s => s.questions);
      const required = flat.filter(q => q.required).map(q => q.question_id);

      return { sections, flat, required };
    }

    function loadLocalDraft(){
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch { return null; }
    }

    function saveLocalDraft(){
      try {
        const draft = {
          respondent: {
            name: $("name").value.trim(),
            email: $("email").value.trim(),
            organization: $("org").value.trim()
          },
          case_id: $("caseId").value.trim() || null,
          answers: ANSWERS,
          saved_at: new Date().toISOString()
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(draft));
      } catch {}
    }

    function resetLocalDraft(){
      try { localStorage.removeItem(STORAGE_KEY); } catch {}
      ANSWERS = {};
      renderAll(); // refresh
      setSubmitHint("Saved draft cleared.", "ok");
    }

    function setProgress(){
      const totalReq = REQUIRED_IDS.length;
      const answeredReq = REQUIRED_IDS.filter(id => isAnswered(id)).length;
      const percent = totalReq ? Math.round((answeredReq / totalReq) * 100) : 0;

      $("progressFill").style.width = percent + "%";
      $("progressText").textContent = CONFIG
        ? `Progress: ${answeredReq}/${totalReq} required answered (${percent}%)`
        : "Loading questions…";
    }

    function isAnswered(qid){
      const v = ANSWERS[qid];
      if (v === null || v === undefined) return false;
      if (typeof v === "string") return v.trim().length > 0;
      if (Array.isArray(v)) return v.length > 0;
      return true; // numbers/booleans
    }

    function getMissingRequired(){
      return REQUIRED_IDS.filter(id => !isAnswered(id));
    }

    function showMissing(){
      const missing = getMissingRequired();
      if (!missing.length) {
        $("missingBox").style.display = "none";
        return;
      }
      $("missingBox").style.display = "block";
      const ul = $("missingList");
      ul.innerHTML = "";
      const missingTexts = new Map(QUESTIONS.map(q => [q.question_id, q.text]));
      missing.slice(0, 30).forEach(id => {
        const li = document.createElement("li");
        li.innerHTML = `<span class="mono">${esc(id)}</span> — ${esc(missingTexts.get(id) || "Required question")}`;
        ul.appendChild(li);
      });
      if (missing.length > 30) {
        const li = document.createElement("li");
        li.textContent = `…and ${missing.length - 30} more.`;
        ul.appendChild(li);
      }
    }

    function setSubmitStatus(msg, cls){
      const el = $("submitStatus");
      el.className = "status " + (cls || "");
      el.textContent = msg || "";
    }

    function setSubmitHint(msg, cls){
      const el = $("submitHint");
      el.className = "hint " + (cls || "");
      el.textContent = msg || "";
    }

    function scrollToTop(){ window.scrollTo({ top: 0, behavior: "smooth" }); }

    // =========================
    // Rendering
    // =========================
    function renderQuestion(q){
      const wrap = document.createElement("div");
      wrap.className = "qCard";
      wrap.id = `q_${q.question_id}`;

      const meta = document.createElement("div");
      meta.className = "qMeta";
      meta.innerHTML = `
        <div class="qid mono">${esc(q.question_id)}</div>
        <div class="req">${q.required ? "<b>Required</b>" : "Optional"}</div>
      `;

      const text = document.createElement("div");
      text.className = "qText";
      text.innerHTML = esc(q.text);

      const current = ANSWERS[q.question_id];

      const inputArea = document.createElement("div");

      if (q.type === "likert") {
        const min = Number.isFinite(q.likert?.min) ? q.likert.min : 1;
        const max = Number.isFinite(q.likert?.max) ? q.likert.max : 5;
        const grid = document.createElement("div");
        grid.className = "likert";

        for (let v = min; v <= max; v++) {
          const opt = document.createElement("label");
          opt.className = "opt";
          const checked = Number(current) === v;
          opt.innerHTML = `<input type="radio" name="${esc(q.question_id)}" value="${v}" ${checked ? "checked" : ""} /> <span>${v}</span>`;
          opt.addEventListener("change", () => {
            ANSWERS[q.question_id] = v;
            saveLocalDraft();
            setProgress();
            showMissing();
          });
          grid.appendChild(opt);
        }
        inputArea.appendChild(grid);

      } else if (q.type === "single") {
        const opts = Array.isArray(q.options) ? q.options : [];
        if (opts.length <= 8) {
          const row = document.createElement("div");
          row.className = "opts";
          opts.forEach(o => {
            const val = o.value;
            const label = o.label;
            const checked = String(current) === String(val);
            const opt = document.createElement("label");
            opt.className = "opt";
            opt.innerHTML = `<input type="radio" name="${esc(q.question_id)}" value="${esc(val)}" ${checked ? "checked" : ""} /> <span>${esc(label)}</span>`;
            opt.addEventListener("change", () => {
              ANSWERS[q.question_id] = val;
              saveLocalDraft();
              setProgress();
              showMissing();
            });
            row.appendChild(opt);
          });
          inputArea.appendChild(row);
        } else {
          const sel = document.createElement("select");
          sel.innerHTML = `<option value="">Select…</option>` + opts.map(o => `<option value="${esc(o.value)}">${esc(o.label)}</option>`).join("");
          if (current !== undefined && current !== null) sel.value = String(current);
          sel.addEventListener("change", () => {
            const v = sel.value;
            ANSWERS[q.question_id] = v ? v : null;
            saveLocalDraft();
            setProgress();
            showMissing();
          });
          inputArea.appendChild(sel);
        }

      } else if (q.type === "multi") {
        const opts = Array.isArray(q.options) ? q.options : [];
        const row = document.createElement("div");
        row.className = "opts";
        const arr = Array.isArray(current) ? current.map(String) : [];
        opts.forEach(o => {
          const val = String(o.value);
          const label = o.label;
          const checked = arr.includes(val);
          const opt = document.createElement("label");
          opt.className = "opt";
          opt.innerHTML = `<input type="checkbox" value="${esc(val)}" ${checked ? "checked" : ""} /> <span>${esc(label)}</span>`;
          opt.addEventListener("change", (ev) => {
            const cb = ev.target;
            const set = new Set(Array.isArray(ANSWERS[q.question_id]) ? ANSWERS[q.question_id].map(String) : []);
            if (cb.checked) set.add(val);
            else set.delete(val);
            const out = Array.from(set);
            ANSWERS[q.question_id] = out;
            saveLocalDraft();
            setProgress();
            showMissing();
          });
          row.appendChild(opt);
        });
        inputArea.appendChild(row);

      } else if (q.type === "longtext") {
        const ta = document.createElement("textarea");
        ta.placeholder = "Type your answer…";
        ta.value = (typeof current === "string") ? current : "";
        ta.addEventListener("input", () => {
          ANSWERS[q.question_id] = ta.value;
          saveLocalDraft();
          setProgress();
          showMissing();
        });
        inputArea.appendChild(ta);

      } else { // text
        const inp = document.createElement("input");
        inp.placeholder = "Type your answer…";
        inp.value = (typeof current === "string") ? current : "";
        inp.addEventListener("input", () => {
          ANSWERS[q.question_id] = inp.value;
          saveLocalDraft();
          setProgress();
          showMissing();
        });
        inputArea.appendChild(inp);
      }

      wrap.appendChild(meta);
      wrap.appendChild(text);
      wrap.appendChild(inputArea);

      return wrap;
    }

    function renderAll(){
      const root = $("questionsRoot");
      root.innerHTML = "";

      if (!CONFIG || !SECTIONS.length) return;

      SECTIONS.forEach(sec => {
        const h = document.createElement("div");
        h.style.margin = "0 0 10px";
        h.innerHTML = `<div class="sectionTitle">${esc(sec.title)}</div>`;
        root.appendChild(h);

        const box = document.createElement("div");
        box.style.display = "grid";
        box.style.gap = "10px";

        sec.questions.forEach(q => box.appendChild(renderQuestion(q)));
        root.appendChild(box);

        const spacer = document.createElement("div");
        spacer.className = "hr";
        root.appendChild(spacer);
      });

      setProgress();
      showMissing();
    }

    // =========================
    // Loading config + draft
    // =========================
    async function loadConfigAndInit(){
      $("questionsStatus").textContent = `Loading configuration from ${CONFIG_URL}…`;

      try {
        const res = await fetch(CONFIG_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`Config HTTP ${res.status}`);
        const raw = await res.json();

        const cfg = normalizeConfig(raw);
        if (!cfg) throw new Error("Unsupported config JSON shape");

        const model = buildModel(cfg);
        CONFIG = raw;
        SECTIONS = model.sections;
        QUESTIONS = model.flat;
        REQUIRED_IDS = model.required;

        $("questionsStatus").textContent = `Loaded ${QUESTIONS.length} questions in ${SECTIONS.length} section(s).`;

        // Load saved draft
        const saved = loadLocalDraft();
        if (saved && saved.answers && typeof saved.answers === "object") {
          ANSWERS = saved.answers || {};
          // Restore respondent fields if empty
          if (!$("name").value.trim() && saved.respondent?.name) $("name").value = saved.respondent.name;
          if (!$("email").value.trim() && saved.respondent?.email) $("email").value = saved.respondent.email;
          if (!$("org").value.trim() && saved.respondent?.organization) $("org").value = saved.respondent.organization;
          if (!$("caseId").value.trim() && saved.case_id) $("caseId").value = saved.case_id;
        }

        // autosave respondent fields
        ["name","email","org","caseId"].forEach(id => {
          $(id).addEventListener("input", () => saveLocalDraft());
        });

        renderAll();
        setSubmitHint("All set. Please complete required questions and submit.", "");

      } catch (e) {
        // fallback mode
        FALLBACK_MODE = true;
        $("questionsStatus").textContent = "Config load failed. Fallback mode enabled.";
        $("questionsStatus").className = "status error";
        $("fallback").style.display = "block";
        setProgress();
        setSubmitHint("Fallback mode: paste answers JSON and submit. Fix config to enable full assessment UI.", "error");
      }
    }

    // =========================
    // Submit
    // =========================
    function buildAnswersArray(){
      // convert ANSWERS map into array [{question_id, value}]
      const out = [];
      if (!QUESTIONS.length) {
        // fallback: accept raw JSON
        const raw = $("answersJson") ? $("answersJson").value : "";
        if (raw && raw.trim()) {
          try {
            const arr = JSON.parse(raw);
            if (Array.isArray(arr)) return arr;
          } catch {}
        }
        return [];
      }

      // Use questions order for predictable output
      QUESTIONS.forEach(q => {
        if (ANSWERS[q.question_id] !== undefined && ANSWERS[q.question_id] !== null && !(typeof ANSWERS[q.question_id] === "string" && !ANSWERS[q.question_id].trim())) {
          out.push({ question_id: q.question_id, value: ANSWERS[q.question_id] });
        }
      });

      return out;
    }

    async function submitForm(){
      const btn = $("sendBtn");
      btn.disabled = true;
      setSubmitStatus("Submitting…", "");
      setSubmitHint("", "");

      try {
        const respondent = {
          name: $("name").value.trim(),
          email: $("email").value.trim(),
          organization: $("org").value.trim()
        };

        if (!respondent.email) {
          setSubmitStatus("Missing email.", "error");
          setSubmitHint("Please provide respondent email (report recipient).", "error");
          btn.disabled = false;
          return;
        }

        if (!FALLBACK_MODE) {
          const missing = getMissingRequired();
          if (missing.length) {
            setSubmitStatus("Incomplete.", "error");
            setSubmitHint("Please answer all required questions before submitting.", "error");
            showMissing();
            btn.disabled = false;
            // scroll to missing box
            $("missingBox").scrollIntoView({ behavior: "smooth", block: "start" });
            return;
          }
        } else {
          // fallback validation
          const raw = $("answersJson").value.trim();
          if (!raw) {
            setSubmitStatus("Missing answers JSON.", "error");
            setSubmitHint("Fallback mode: paste answers JSON array.", "error");
            btn.disabled = false;
            return;
          }
          try {
            const arr = JSON.parse(raw);
            if (!Array.isArray(arr)) throw new Error("Answers JSON must be an array");
          } catch (e) {
            setSubmitStatus("Invalid JSON.", "error");
            setSubmitHint(e.message || "Invalid answers JSON.", "error");
            btn.disabled = false;
            return;
          }
        }

        const caseId = $("caseId").value.trim();
        const payload = {
          ...(caseId ? { case_id: caseId } : {}),
          respondent,
          answers: buildAnswersArray()
        };

        // persist
        saveLocalDraft();

        const res = await fetch("/api/intake/submit", {
          method: "POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify(payload)
        });

        const data = await res.json().catch(() => null);

        if (!res.ok || !data) throw new Error((data && data.error) ? data.error : `HTTP ${res.status}`);

        if (data.ok && data.thank_you_url) {
          // Clear local draft after successful submit (optional; keeps system clean)
          try { localStorage.removeItem(STORAGE_KEY); } catch {}
          window.location.href = data.thank_you_url;
          return;
        }

        setSubmitStatus("Submitted.", "ok");
        setSubmitHint("Submission stored. Thank-you redirect was not provided by the server.", "");

      } catch (e) {
        setSubmitStatus("Submit failed.", "error");
        setSubmitHint(e && e.message ? e.message : String(e), "error");
      } finally {
        btn.disabled = false;
      }
    }

    // =========================
    // Boot
    // =========================
    checkHealth();
    loadConfigAndInit();
  </script>
</body>
</html>
